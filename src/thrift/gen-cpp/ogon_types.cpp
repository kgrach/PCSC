/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ogon_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>




return_ec::~return_ec() noexcept {
}


void return_ec::__set_retValue(const LONG_RPC val) {
  this->retValue = val;
}

void return_ec::__set_cardContext(const SCARDCONTEXT_RPC val) {
  this->cardContext = val;
}
std::ostream& operator<<(std::ostream& out, const return_ec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t return_ec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->retValue);
          this->__isset.retValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cardContext);
          this->__isset.cardContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t return_ec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("return_ec");

  xfer += oprot->writeFieldBegin("retValue", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->retValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cardContext", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->cardContext);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(return_ec &a, return_ec &b) {
  using ::std::swap;
  swap(a.retValue, b.retValue);
  swap(a.cardContext, b.cardContext);
  swap(a.__isset, b.__isset);
}

return_ec::return_ec(const return_ec& other0) {
  retValue = other0.retValue;
  cardContext = other0.cardContext;
  __isset = other0.__isset;
}
return_ec& return_ec::operator=(const return_ec& other1) {
  retValue = other1.retValue;
  cardContext = other1.cardContext;
  __isset = other1.__isset;
  return *this;
}
void return_ec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "return_ec(";
  out << "retValue=" << to_string(retValue);
  out << ", " << "cardContext=" << to_string(cardContext);
  out << ")";
}


return_rc::~return_rc() noexcept {
}


void return_rc::__set_retValue(const LONG_RPC val) {
  this->retValue = val;
}
std::ostream& operator<<(std::ostream& out, const return_rc& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t return_rc::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->retValue);
          this->__isset.retValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t return_rc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("return_rc");

  xfer += oprot->writeFieldBegin("retValue", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->retValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(return_rc &a, return_rc &b) {
  using ::std::swap;
  swap(a.retValue, b.retValue);
  swap(a.__isset, b.__isset);
}

return_rc::return_rc(const return_rc& other2) {
  retValue = other2.retValue;
  __isset = other2.__isset;
}
return_rc& return_rc::operator=(const return_rc& other3) {
  retValue = other3.retValue;
  __isset = other3.__isset;
  return *this;
}
void return_rc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "return_rc(";
  out << "retValue=" << to_string(retValue);
  out << ")";
}


return_lr::~return_lr() noexcept {
}


void return_lr::__set_retValue(const LONG_RPC val) {
  this->retValue = val;
}

void return_lr::__set_mszReaders(const LPBYTE_RPC& val) {
  this->mszReaders = val;
}
std::ostream& operator<<(std::ostream& out, const return_lr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t return_lr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->retValue);
          this->__isset.retValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->mszReaders);
          this->__isset.mszReaders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t return_lr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("return_lr");

  xfer += oprot->writeFieldBegin("retValue", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->retValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mszReaders", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->mszReaders);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(return_lr &a, return_lr &b) {
  using ::std::swap;
  swap(a.retValue, b.retValue);
  swap(a.mszReaders, b.mszReaders);
  swap(a.__isset, b.__isset);
}

return_lr::return_lr(const return_lr& other4) {
  retValue = other4.retValue;
  mszReaders = other4.mszReaders;
  __isset = other4.__isset;
}
return_lr& return_lr::operator=(const return_lr& other5) {
  retValue = other5.retValue;
  mszReaders = other5.mszReaders;
  __isset = other5.__isset;
  return *this;
}
void return_lr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "return_lr(";
  out << "retValue=" << to_string(retValue);
  out << ", " << "mszReaders=" << to_string(mszReaders);
  out << ")";
}


return_lrg::~return_lrg() noexcept {
}


void return_lrg::__set_retValue(const LONG_RPC val) {
  this->retValue = val;
}

void return_lrg::__set_mszGroups(const LPBYTE_RPC& val) {
  this->mszGroups = val;
}
std::ostream& operator<<(std::ostream& out, const return_lrg& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t return_lrg::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->retValue);
          this->__isset.retValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->mszGroups);
          this->__isset.mszGroups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t return_lrg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("return_lrg");

  xfer += oprot->writeFieldBegin("retValue", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->retValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mszGroups", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->mszGroups);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(return_lrg &a, return_lrg &b) {
  using ::std::swap;
  swap(a.retValue, b.retValue);
  swap(a.mszGroups, b.mszGroups);
  swap(a.__isset, b.__isset);
}

return_lrg::return_lrg(const return_lrg& other6) {
  retValue = other6.retValue;
  mszGroups = other6.mszGroups;
  __isset = other6.__isset;
}
return_lrg& return_lrg::operator=(const return_lrg& other7) {
  retValue = other7.retValue;
  mszGroups = other7.mszGroups;
  __isset = other7.__isset;
  return *this;
}
void return_lrg::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "return_lrg(";
  out << "retValue=" << to_string(retValue);
  out << ", " << "mszGroups=" << to_string(mszGroups);
  out << ")";
}


return_c::~return_c() noexcept {
}


void return_c::__set_retValue(const LONG_RPC val) {
  this->retValue = val;
}

void return_c::__set_phCard(const SCARDHANDLE_RPC val) {
  this->phCard = val;
}

void return_c::__set_pdwActiveProtocol(const DWORD_RPC val) {
  this->pdwActiveProtocol = val;
}
std::ostream& operator<<(std::ostream& out, const return_c& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t return_c::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->retValue);
          this->__isset.retValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->phCard);
          this->__isset.phCard = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->pdwActiveProtocol);
          this->__isset.pdwActiveProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t return_c::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("return_c");

  xfer += oprot->writeFieldBegin("retValue", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->retValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("phCard", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->phCard);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pdwActiveProtocol", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->pdwActiveProtocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(return_c &a, return_c &b) {
  using ::std::swap;
  swap(a.retValue, b.retValue);
  swap(a.phCard, b.phCard);
  swap(a.pdwActiveProtocol, b.pdwActiveProtocol);
  swap(a.__isset, b.__isset);
}

return_c::return_c(const return_c& other8) {
  retValue = other8.retValue;
  phCard = other8.phCard;
  pdwActiveProtocol = other8.pdwActiveProtocol;
  __isset = other8.__isset;
}
return_c& return_c::operator=(const return_c& other9) {
  retValue = other9.retValue;
  phCard = other9.phCard;
  pdwActiveProtocol = other9.pdwActiveProtocol;
  __isset = other9.__isset;
  return *this;
}
void return_c::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "return_c(";
  out << "retValue=" << to_string(retValue);
  out << ", " << "phCard=" << to_string(phCard);
  out << ", " << "pdwActiveProtocol=" << to_string(pdwActiveProtocol);
  out << ")";
}


return_s::~return_s() noexcept {
}


void return_s::__set_retValue(const LONG_RPC val) {
  this->retValue = val;
}

void return_s::__set_szReaderName(const LPBYTE_RPC& val) {
  this->szReaderName = val;
}

void return_s::__set_pdwState(const DWORD_RPC val) {
  this->pdwState = val;
}

void return_s::__set_pdwProtocol(const DWORD_RPC val) {
  this->pdwProtocol = val;
}

void return_s::__set_pbAtr(const LPBYTE_RPC& val) {
  this->pbAtr = val;
}
std::ostream& operator<<(std::ostream& out, const return_s& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t return_s::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->retValue);
          this->__isset.retValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->szReaderName);
          this->__isset.szReaderName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->pdwState);
          this->__isset.pdwState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->pdwProtocol);
          this->__isset.pdwProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pbAtr);
          this->__isset.pbAtr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t return_s::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("return_s");

  xfer += oprot->writeFieldBegin("retValue", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->retValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("szReaderName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->szReaderName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pdwState", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->pdwState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pdwProtocol", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->pdwProtocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pbAtr", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->pbAtr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(return_s &a, return_s &b) {
  using ::std::swap;
  swap(a.retValue, b.retValue);
  swap(a.szReaderName, b.szReaderName);
  swap(a.pdwState, b.pdwState);
  swap(a.pdwProtocol, b.pdwProtocol);
  swap(a.pbAtr, b.pbAtr);
  swap(a.__isset, b.__isset);
}

return_s::return_s(const return_s& other10) {
  retValue = other10.retValue;
  szReaderName = other10.szReaderName;
  pdwState = other10.pdwState;
  pdwProtocol = other10.pdwProtocol;
  pbAtr = other10.pbAtr;
  __isset = other10.__isset;
}
return_s& return_s::operator=(const return_s& other11) {
  retValue = other11.retValue;
  szReaderName = other11.szReaderName;
  pdwState = other11.pdwState;
  pdwProtocol = other11.pdwProtocol;
  pbAtr = other11.pbAtr;
  __isset = other11.__isset;
  return *this;
}
void return_s::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "return_s(";
  out << "retValue=" << to_string(retValue);
  out << ", " << "szReaderName=" << to_string(szReaderName);
  out << ", " << "pdwState=" << to_string(pdwState);
  out << ", " << "pdwProtocol=" << to_string(pdwProtocol);
  out << ", " << "pbAtr=" << to_string(pbAtr);
  out << ")";
}


scard_io_request_rpc::~scard_io_request_rpc() noexcept {
}


void scard_io_request_rpc::__set_dwProtocol(const LONG_RPC val) {
  this->dwProtocol = val;
}

void scard_io_request_rpc::__set_cbPciLength(const LONG_RPC val) {
  this->cbPciLength = val;
}
std::ostream& operator<<(std::ostream& out, const scard_io_request_rpc& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t scard_io_request_rpc::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dwProtocol);
          this->__isset.dwProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cbPciLength);
          this->__isset.cbPciLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t scard_io_request_rpc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("scard_io_request_rpc");

  xfer += oprot->writeFieldBegin("dwProtocol", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->dwProtocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cbPciLength", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->cbPciLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(scard_io_request_rpc &a, scard_io_request_rpc &b) {
  using ::std::swap;
  swap(a.dwProtocol, b.dwProtocol);
  swap(a.cbPciLength, b.cbPciLength);
  swap(a.__isset, b.__isset);
}

scard_io_request_rpc::scard_io_request_rpc(const scard_io_request_rpc& other12) {
  dwProtocol = other12.dwProtocol;
  cbPciLength = other12.cbPciLength;
  __isset = other12.__isset;
}
scard_io_request_rpc& scard_io_request_rpc::operator=(const scard_io_request_rpc& other13) {
  dwProtocol = other13.dwProtocol;
  cbPciLength = other13.cbPciLength;
  __isset = other13.__isset;
  return *this;
}
void scard_io_request_rpc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "scard_io_request_rpc(";
  out << "dwProtocol=" << to_string(dwProtocol);
  out << ", " << "cbPciLength=" << to_string(cbPciLength);
  out << ")";
}


return_t::~return_t() noexcept {
}


void return_t::__set_retValue(const LONG_RPC val) {
  this->retValue = val;
}

void return_t::__set_pioRecvPci(const scard_io_request_rpc& val) {
  this->pioRecvPci = val;
}

void return_t::__set_pbRecvBuffer(const LPBYTE_RPC& val) {
  this->pbRecvBuffer = val;
}
std::ostream& operator<<(std::ostream& out, const return_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t return_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->retValue);
          this->__isset.retValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pioRecvPci.read(iprot);
          this->__isset.pioRecvPci = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pbRecvBuffer);
          this->__isset.pbRecvBuffer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t return_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("return_t");

  xfer += oprot->writeFieldBegin("retValue", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->retValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pioRecvPci", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->pioRecvPci.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pbRecvBuffer", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->pbRecvBuffer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(return_t &a, return_t &b) {
  using ::std::swap;
  swap(a.retValue, b.retValue);
  swap(a.pioRecvPci, b.pioRecvPci);
  swap(a.pbRecvBuffer, b.pbRecvBuffer);
  swap(a.__isset, b.__isset);
}

return_t::return_t(const return_t& other14) {
  retValue = other14.retValue;
  pioRecvPci = other14.pioRecvPci;
  pbRecvBuffer = other14.pbRecvBuffer;
  __isset = other14.__isset;
}
return_t& return_t::operator=(const return_t& other15) {
  retValue = other15.retValue;
  pioRecvPci = other15.pioRecvPci;
  pbRecvBuffer = other15.pbRecvBuffer;
  __isset = other15.__isset;
  return *this;
}
void return_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "return_t(";
  out << "retValue=" << to_string(retValue);
  out << ", " << "pioRecvPci=" << to_string(pioRecvPci);
  out << ", " << "pbRecvBuffer=" << to_string(pbRecvBuffer);
  out << ")";
}


return_r::~return_r() noexcept {
}


void return_r::__set_retValue(const LONG_RPC val) {
  this->retValue = val;
}

void return_r::__set_pdwActiveProtocol(const DWORD_RPC val) {
  this->pdwActiveProtocol = val;
}
std::ostream& operator<<(std::ostream& out, const return_r& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t return_r::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->retValue);
          this->__isset.retValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->pdwActiveProtocol);
          this->__isset.pdwActiveProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t return_r::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("return_r");

  xfer += oprot->writeFieldBegin("retValue", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->retValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pdwActiveProtocol", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->pdwActiveProtocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(return_r &a, return_r &b) {
  using ::std::swap;
  swap(a.retValue, b.retValue);
  swap(a.pdwActiveProtocol, b.pdwActiveProtocol);
  swap(a.__isset, b.__isset);
}

return_r::return_r(const return_r& other16) {
  retValue = other16.retValue;
  pdwActiveProtocol = other16.pdwActiveProtocol;
  __isset = other16.__isset;
}
return_r& return_r::operator=(const return_r& other17) {
  retValue = other17.retValue;
  pdwActiveProtocol = other17.pdwActiveProtocol;
  __isset = other17.__isset;
  return *this;
}
void return_r::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "return_r(";
  out << "retValue=" << to_string(retValue);
  out << ", " << "pdwActiveProtocol=" << to_string(pdwActiveProtocol);
  out << ")";
}


scard_readerstate_rpc::~scard_readerstate_rpc() noexcept {
}


void scard_readerstate_rpc::__set_szReader(const LPBYTE_RPC& val) {
  this->szReader = val;
}

void scard_readerstate_rpc::__set_dwCurrentState(const DWORD_RPC val) {
  this->dwCurrentState = val;
}

void scard_readerstate_rpc::__set_dwEventState(const DWORD_RPC val) {
  this->dwEventState = val;
}

void scard_readerstate_rpc::__set_rgbAtr(const LPBYTE_RPC& val) {
  this->rgbAtr = val;
}
std::ostream& operator<<(std::ostream& out, const scard_readerstate_rpc& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t scard_readerstate_rpc::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->szReader);
          this->__isset.szReader = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dwCurrentState);
          this->__isset.dwCurrentState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dwEventState);
          this->__isset.dwEventState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->rgbAtr);
          this->__isset.rgbAtr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t scard_readerstate_rpc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("scard_readerstate_rpc");

  xfer += oprot->writeFieldBegin("szReader", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->szReader);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dwCurrentState", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->dwCurrentState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dwEventState", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->dwEventState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rgbAtr", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->rgbAtr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(scard_readerstate_rpc &a, scard_readerstate_rpc &b) {
  using ::std::swap;
  swap(a.szReader, b.szReader);
  swap(a.dwCurrentState, b.dwCurrentState);
  swap(a.dwEventState, b.dwEventState);
  swap(a.rgbAtr, b.rgbAtr);
  swap(a.__isset, b.__isset);
}

scard_readerstate_rpc::scard_readerstate_rpc(const scard_readerstate_rpc& other18) {
  szReader = other18.szReader;
  dwCurrentState = other18.dwCurrentState;
  dwEventState = other18.dwEventState;
  rgbAtr = other18.rgbAtr;
  __isset = other18.__isset;
}
scard_readerstate_rpc& scard_readerstate_rpc::operator=(const scard_readerstate_rpc& other19) {
  szReader = other19.szReader;
  dwCurrentState = other19.dwCurrentState;
  dwEventState = other19.dwEventState;
  rgbAtr = other19.rgbAtr;
  __isset = other19.__isset;
  return *this;
}
void scard_readerstate_rpc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "scard_readerstate_rpc(";
  out << "szReader=" << to_string(szReader);
  out << ", " << "dwCurrentState=" << to_string(dwCurrentState);
  out << ", " << "dwEventState=" << to_string(dwEventState);
  out << ", " << "rgbAtr=" << to_string(rgbAtr);
  out << ")";
}


return_gsc::~return_gsc() noexcept {
}


void return_gsc::__set_retValue(const LONG_RPC val) {
  this->retValue = val;
}

void return_gsc::__set_rgReaderStates(const std::vector<scard_readerstate_rpc> & val) {
  this->rgReaderStates = val;
}
std::ostream& operator<<(std::ostream& out, const return_gsc& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t return_gsc::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->retValue);
          this->__isset.retValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rgReaderStates.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->rgReaderStates.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += this->rgReaderStates[_i24].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rgReaderStates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t return_gsc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("return_gsc");

  xfer += oprot->writeFieldBegin("retValue", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->retValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rgReaderStates", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rgReaderStates.size()));
    std::vector<scard_readerstate_rpc> ::const_iterator _iter25;
    for (_iter25 = this->rgReaderStates.begin(); _iter25 != this->rgReaderStates.end(); ++_iter25)
    {
      xfer += (*_iter25).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(return_gsc &a, return_gsc &b) {
  using ::std::swap;
  swap(a.retValue, b.retValue);
  swap(a.rgReaderStates, b.rgReaderStates);
  swap(a.__isset, b.__isset);
}

return_gsc::return_gsc(const return_gsc& other26) {
  retValue = other26.retValue;
  rgReaderStates = other26.rgReaderStates;
  __isset = other26.__isset;
}
return_gsc& return_gsc::operator=(const return_gsc& other27) {
  retValue = other27.retValue;
  rgReaderStates = other27.rgReaderStates;
  __isset = other27.__isset;
  return *this;
}
void return_gsc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "return_gsc(";
  out << "retValue=" << to_string(retValue);
  out << ", " << "rgReaderStates=" << to_string(rgReaderStates);
  out << ")";
}


return_ga::~return_ga() noexcept {
}


void return_ga::__set_retValue(const LONG_RPC val) {
  this->retValue = val;
}

void return_ga::__set_pbAttr(const LPBYTE_RPC& val) {
  this->pbAttr = val;
}
std::ostream& operator<<(std::ostream& out, const return_ga& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t return_ga::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->retValue);
          this->__isset.retValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pbAttr);
          this->__isset.pbAttr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t return_ga::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("return_ga");

  xfer += oprot->writeFieldBegin("retValue", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->retValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pbAttr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->pbAttr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(return_ga &a, return_ga &b) {
  using ::std::swap;
  swap(a.retValue, b.retValue);
  swap(a.pbAttr, b.pbAttr);
  swap(a.__isset, b.__isset);
}

return_ga::return_ga(const return_ga& other28) {
  retValue = other28.retValue;
  pbAttr = other28.pbAttr;
  __isset = other28.__isset;
}
return_ga& return_ga::operator=(const return_ga& other29) {
  retValue = other29.retValue;
  pbAttr = other29.pbAttr;
  __isset = other29.__isset;
  return *this;
}
void return_ga::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "return_ga(";
  out << "retValue=" << to_string(retValue);
  out << ", " << "pbAttr=" << to_string(pbAttr);
  out << ")";
}


return_ctrl::~return_ctrl() noexcept {
}


void return_ctrl::__set_retValue(const LONG_RPC val) {
  this->retValue = val;
}

void return_ctrl::__set_pbRecvBuffer(const LPVOID_RPC& val) {
  this->pbRecvBuffer = val;
}
std::ostream& operator<<(std::ostream& out, const return_ctrl& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t return_ctrl::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->retValue);
          this->__isset.retValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pbRecvBuffer);
          this->__isset.pbRecvBuffer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t return_ctrl::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("return_ctrl");

  xfer += oprot->writeFieldBegin("retValue", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->retValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pbRecvBuffer", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->pbRecvBuffer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(return_ctrl &a, return_ctrl &b) {
  using ::std::swap;
  swap(a.retValue, b.retValue);
  swap(a.pbRecvBuffer, b.pbRecvBuffer);
  swap(a.__isset, b.__isset);
}

return_ctrl::return_ctrl(const return_ctrl& other30) {
  retValue = other30.retValue;
  pbRecvBuffer = other30.pbRecvBuffer;
  __isset = other30.__isset;
}
return_ctrl& return_ctrl::operator=(const return_ctrl& other31) {
  retValue = other31.retValue;
  pbRecvBuffer = other31.pbRecvBuffer;
  __isset = other31.__isset;
  return *this;
}
void return_ctrl::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "return_ctrl(";
  out << "retValue=" << to_string(retValue);
  out << ", " << "pbRecvBuffer=" << to_string(pbRecvBuffer);
  out << ")";
}


